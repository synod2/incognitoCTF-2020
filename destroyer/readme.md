destroyer 
----------
```
Ubuntu GLIBC 2.23-0ubuntu11.2 -> 16.04
ELF64
CANARY    : disabled
FORTIFY   : disabled
NX        : ENABLED
PIE       : disabled
RELRO     : FULL
```
프로그램 시작시 이름을 입력받고 , 룰렛 화면이 나온다.
enter 키를 입력하면 룰렛을 다시 돌리는데 여기서 다른 입력을 받는 모양.

시작 부분을 보면 g_ret라는 변수에 retaddr이라는 변수 값을 복사하고, 
retaddr을 -1로 바꿔버리는 부분이 있다. 
이건 프로그램의 리턴 주소를 f로 덮어버린것. 

입력은 0x20만큼 동적할당하여 입력을 받아 전역변수에 저장하고, 
룰렛을 돌리기 전, rbp-0x8 위치에 선언된 buf 변수에 아까 입력한 이름 문자열의 주소가 복사된다. 

룰렛을 돌릴때는 0x40바이트만큼 입력을 받는데,
입력받는 변수 v1에서 오버플로우를 일으켜 v2,v3,v4를 변조해볼수는 있지만 그 다음에 실행되는 함수에 의해
해당 변수들의 값도 변경되는 상황. 

그리고 이때 아까 스택에 저장했던 buf 변수에 들어갈 문자열의 주소값도 변조가 가능하다. 
pie가 걸려있지 않아 전역변수의 주소값은 그대로일듯. 

일단은, g_start 변수가 1인 상태에서 세 변수들의 값이 같아자면 잭팟이 실행되고 
buf에 0x20 바이트만큼 입력을 받게한다. 
이때 ret를 조작하는것이 관건으로 보인다. 

일단 스택을 조작하여 원하는 값을 출력할 수 있는지를 테스트해보자.

음.. 그냥 같은거 나올때까지 돌리다가 같은게 나오면 원샷을 넣어야되나?
일단 libc leak이 되기때문에 원샷가젯의 삽입은 가능한 상황이다. 
그리고 read를 진행할 때 buf에 들어있는 주소 영역에 쓰기를 진행한다. 
즉, 잭팟이 터졌을때 그냥 가젯주소를 쓰면 된다. 

그리고, 이때 buf에 들어있는 주소를 대상으로 쓰기를 진행할 테니 
free의 인자로 들어갈 g_name에 쓰기를 진행하면 안된다. 
오버라이트는 한번만 가능하고, gotoverwrite는 불가능하므로 freehook을 이용해보자. 
그리고 원샷은 불안하다. 시스템 주소를 이용하고, 이름에 애초에 "/bin/sh"를 넣자. 







